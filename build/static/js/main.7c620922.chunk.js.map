{"version":3,"sources":["image.js","proxies.js","moveSelectionToEnd.js","MultiDecorator.js","resolveDecorators.js","createCompositeDecorator.js","defaultKeyBindings.js","defaultKeyCommands.js","customEditor.js","index.js","composeDecorators.js"],"names":["React","Component","proxies","moveSelectionToEnd","editorState","blockMap","getCurrentContent","getBlockMap","key","last","getKey","length","getLength","selection","SelectionState","anchorKey","anchorOffset","focusKey","focusOffset","EditorState","acceptSelection","MultiDecorator","decorators","Object","classCallCheck","this","Immutable","List","block","contentState","decorations","Array","getText","fill","forEach","decorator","i","getDecorations","offset","getDecoratorForKey","getComponentForKey","getInnerKey","getPropsForKey","parts","split","index","Number","get","slice","join","decoratorIsCustom","resolveDecorators","props","getEditorState","onChange","_ref","plugins","concat","toConsumableArray","filter","plugin","undefined","flatMap","getDecoratorsFromProps","compositeDecorator","setEditorState","convertedDecorators","map","objectSpread","component","decorateComponentWithProps","toJS","CompositeDecorator","createCompositeDecorator","customDecorators","push","defaultKeyBindings","keyBindingFn","event","getDefaultKeyBinding","defaultKeyCommands","handleKeyCommand","command","newState","RichUtils","onBackspace","onDelete","getDecoratorLength","obj","_decorators","size","focusPlugin","createFocusPlugin","resizeablePlugin","createResizeablePlugin","blockDndPlugin","createBlockDndPlugin","alignmentPlugin","createAlignmentPlugin","AlignmentTool","_len","arguments","funcs","_key","arg","result","apply","f","composeDecorators","initialState","createImagePlugin","entityMap","0","type","mutability","data","src","blocks","text","depth","inlineStyleRanges","entityRanges","App","_this","possibleConstructorReturn","getPrototypeOf","call","onEditorStateChange","setState","console","log","createWithContent","convertFromRaw","state","react_default","a","createElement","MuiThemeProvider_default","react_draft_wysiwyg","wrapperClassName","editorClassName","toolbar","options","fontFamily","className","dropdownClassName","disabled","value","draftToHtml","convertToRaw","rootElement","document","getElementById","ReactDOM","render","src_App"],"mappings":"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","file":"static/js/main.7c620922.chunk.js","sourcesContent":["import React from \"react\";\r\nimport RaisedButton from \"material-ui/RaisedButton\";\r\nimport { GridList, GridTile } from \"material-ui/GridList\";\r\nimport IconButton from \"material-ui/IconButton\";\r\nimport Subheader from \"material-ui/Subheader\";\r\nimport StarBorder from \"material-ui/svg-icons/toggle/star-border\";\r\n\r\nconst styles = {\r\n  root: {\r\n    display: \"flex\",\r\n    flexWrap: \"wrap\",\r\n    justifyContent: \"space-around\"\r\n  },\r\n  gridList: {\r\n    width: 500,\r\n    height: 450,\r\n    overflowY: \"auto\"\r\n  }\r\n};\r\n\r\n// export interface IImage {\r\n//   id?: string;\r\n//   title?: string;\r\n//   description?: string;\r\n//   datetime?: number;\r\n//   type?: string;\r\n//   account_url?: string;\r\n//   account_id?: number;\r\n//   name?: string;\r\n//   link?: string;\r\n// }\r\n\r\n// export interface IImageState {\r\n//   images?: IImage[];\r\n// }\r\n\r\nexport default class ImageComponent extends React.Component {\r\n  state = {\r\n    images: []\r\n  };\r\n  componentDidMount() {\r\n    this.getImages();\r\n  }\r\n  getImages = () => {\r\n    const url = \"https://api.imgur.com/3/account/abhimanyu001/images/0\";\r\n    const access_token = \"61427ae26768e96031d45ef20eda5e93ac7c7de6\";\r\n    fetch(url, {\r\n      method: \"get\",\r\n      headers: new Headers({\r\n        Authorization: `Bearer ${access_token}`,\r\n        \"Content-Type\": \"application/json\"\r\n      })\r\n    })\r\n      .then(response => response.json())\r\n      .then(response => {\r\n        const { data } = response;\r\n        const pData = data.map(d => ({\r\n          id: d.id,\r\n          title: d.title,\r\n          description: d.description,\r\n          datetime: d.datetime,\r\n          type: d.type,\r\n          account_url: d.account_url,\r\n          account_id: d.account_id,\r\n          name: d.name,\r\n          link: d.link\r\n        }));\r\n        this.setState({\r\n          images: pData.slice()\r\n        });\r\n      });\r\n  };\r\n  render() {\r\n    const { images } = this.state;\r\n    return (\r\n      <div>\r\n        <div>\r\n          <GridList cellHeight={180}>\r\n            <Subheader>Images</Subheader>\r\n            {images.map(image => (\r\n              <GridTile\r\n                key={image.account_url}\r\n                title={image.title}\r\n                subtitle={\r\n                  <span>\r\n                    by <b>{image.name}</b>\r\n                  </span>\r\n                }\r\n                actionIcon={\r\n                  <IconButton>\r\n                    <StarBorder color=\"white\" />\r\n                  </IconButton>\r\n                }\r\n              >\r\n                <img src={image.link} />\r\n              </GridTile>\r\n            ))}\r\n          </GridList>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","const proxies = [\r\n  \"focus\",\r\n  \"blur\",\r\n  \"setMode\",\r\n  \"exitCurrentMode\",\r\n  \"restoreEditorDOM\",\r\n  \"setRenderGuard\",\r\n  \"removeRenderGuard\",\r\n  \"setClipboard\",\r\n  \"getClipboard\",\r\n  \"getEditorKey\",\r\n  \"update\",\r\n  \"onDragEnter\",\r\n  \"onDragLeave\"\r\n];\r\n\r\nexport default proxies;\r\n","import { EditorState, SelectionState } from \"draft-js\";\r\n\r\n/**\r\n * Returns a new EditorState where the Selection is at the end.\r\n *\r\n * This ensures to mimic the textarea behaviour where the Selection is placed at\r\n * the end. This is needed when blocks (like stickers or other media) are added\r\n * without the editor having had focus yet. It still works to place the\r\n * Selection at a specific location by clicking on the text.\r\n */\r\nconst moveSelectionToEnd = editorState => {\r\n  const content = editorState.getCurrentContent();\r\n  const blockMap = content.getBlockMap();\r\n\r\n  const key = blockMap.last().getKey();\r\n  const length = blockMap.last().getLength();\r\n\r\n  const selection = new SelectionState({\r\n    anchorKey: key,\r\n    anchorOffset: length,\r\n    focusKey: key,\r\n    focusOffset: length\r\n  });\r\n\r\n  return EditorState.acceptSelection(editorState, selection);\r\n};\r\n\r\nexport default moveSelectionToEnd;\r\n","import Immutable from \"immutable\";\r\n\r\nconst KEY_SEPARATOR = \"-\";\r\n\r\nexport default class MultiDecorator {\r\n  constructor(decorators) {\r\n    this.decorators = Immutable.List(decorators);\r\n  }\r\n\r\n  /**\r\n   * Return list of decoration IDs per character\r\n   *\r\n   * @param {ContentBlock} block\r\n   * @return {List<String>}\r\n   */\r\n  getDecorations(block, contentState) {\r\n    const decorations = new Array(block.getText().length).fill(null);\r\n\r\n    this.decorators.forEach((decorator, i) => {\r\n      const subDecorations = decorator.getDecorations(block, contentState);\r\n\r\n      subDecorations.forEach((key, offset) => {\r\n        if (!key) {\r\n          return;\r\n        }\r\n\r\n        decorations[offset] = i + KEY_SEPARATOR + key;\r\n      });\r\n    });\r\n\r\n    return Immutable.List(decorations);\r\n  }\r\n\r\n  /**\r\n   * Return component to render a decoration\r\n   *\r\n   * @param {String} key\r\n   * @return {Function}\r\n   */\r\n  getComponentForKey(key) {\r\n    const decorator = this.getDecoratorForKey(key);\r\n    return decorator.getComponentForKey(MultiDecorator.getInnerKey(key));\r\n  }\r\n\r\n  /**\r\n   * Return props to render a decoration\r\n   *\r\n   * @param {String} key\r\n   * @return {Object}\r\n   */\r\n  getPropsForKey(key) {\r\n    const decorator = this.getDecoratorForKey(key);\r\n    return decorator.getPropsForKey(MultiDecorator.getInnerKey(key));\r\n  }\r\n\r\n  /**\r\n   * Return a decorator for a specific key\r\n   *\r\n   * @param {String} key\r\n   * @return {Decorator}\r\n   */\r\n  getDecoratorForKey(key) {\r\n    const parts = key.split(KEY_SEPARATOR);\r\n    const index = Number(parts[0]);\r\n\r\n    return this.decorators.get(index);\r\n  }\r\n\r\n  /**\r\n   * Return inner key for a decorator\r\n   *\r\n   * @param {String} key\r\n   * @return {String}\r\n   */\r\n  static getInnerKey(key) {\r\n    const parts = key.split(KEY_SEPARATOR);\r\n    return parts.slice(1).join(KEY_SEPARATOR);\r\n  }\r\n}\r\n","import { List } from \"immutable\";\r\nimport createCompositeDecorator from \"./createCompositeDecorator\";\r\nimport MultiDecorator from \"./MultiDecorator\";\r\n\r\n// Return true if decorator implements the DraftDecoratorType interface\r\n// @see https://github.com/facebook/draft-js/blob/master/src/model/decorators/DraftDecoratorType.js\r\nconst decoratorIsCustom = decorator =>\r\n  typeof decorator.getDecorations === \"function\" &&\r\n  typeof decorator.getComponentForKey === \"function\" &&\r\n  typeof decorator.getPropsForKey === \"function\";\r\n\r\nconst getDecoratorsFromProps = ({ decorators, plugins }) => {\r\n  plugins = plugins || [];\r\n  return List([{ decorators }, ...plugins])\r\n    .filter(plugin => plugin.decorators !== undefined)\r\n    .flatMap(plugin => plugin.decorators);\r\n};\r\n\r\nconst resolveDecorators = (props, getEditorState, onChange) => {\r\n  const decorators = getDecoratorsFromProps(props);\r\n  const compositeDecorator = createCompositeDecorator(\r\n    decorators.filter(decorator => !decoratorIsCustom(decorator)),\r\n    getEditorState,\r\n    onChange\r\n  );\r\n\r\n  const customDecorators = decorators.filter(decorator =>\r\n    decoratorIsCustom(decorator)\r\n  );\r\n\r\n  return new MultiDecorator(customDecorators.push(compositeDecorator));\r\n};\r\n\r\nexport default resolveDecorators;\r\n","/**\r\n * Creates a composite decorator based on the provided plugins\r\n */\r\n\r\nimport { List } from \"immutable\";\r\nimport { CompositeDecorator } from \"draft-js\";\r\nimport decorateComponentWithProps from \"decorate-component-with-props\";\r\n\r\nexport default (decorators, getEditorState, setEditorState) => {\r\n  const convertedDecorators = List(decorators)\r\n    .map(decorator => ({\r\n      ...decorator,\r\n      component: decorateComponentWithProps(decorator.component, {\r\n        getEditorState,\r\n        setEditorState\r\n      })\r\n    }))\r\n    .toJS();\r\n\r\n  return new CompositeDecorator(convertedDecorators);\r\n};\r\n","import { getDefaultKeyBinding } from \"draft-js\";\r\n\r\nexport default {\r\n  keyBindingFn: event => getDefaultKeyBinding(event)\r\n};\r\n","import { RichUtils } from \"draft-js\";\r\n\r\nexport default {\r\n  // handle delete commands\r\n  handleKeyCommand: (command, editorState, { setEditorState }) => {\r\n    let newState;\r\n    switch (command) {\r\n      case \"backspace\":\r\n      case \"backspace-word\":\r\n      case \"backspace-to-start-of-line\":\r\n        newState = RichUtils.onBackspace(editorState);\r\n        break;\r\n      case \"delete\":\r\n      case \"delete-word\":\r\n      case \"delete-to-end-of-block\":\r\n        newState = RichUtils.onDelete(editorState);\r\n        break;\r\n      default:\r\n        return \"not-handled\";\r\n    }\r\n\r\n    if (newState != null) {\r\n      setEditorState(newState);\r\n      return \"handled\";\r\n    }\r\n\r\n    return \"not-handled\";\r\n  }\r\n};\r\n","import { Editor } from \"react-draft-wysiwyg\";\r\nimport React from \"react\";\r\nimport { EditorState, convertToRaw, ContentState } from \"draft-js\";\r\nimport { Map } from \"immutable\";\r\nimport proxies from \"./proxies\";\r\nimport moveSelectionToEnd from \"./moveSelectionToEnd\";\r\nimport resolveDecorators from \"./resolveDecorators\";\r\nimport defaultKeyBindings from \"./defaultKeyBindings\";\r\nimport defaultKeyCommands from \"./defaultKeyCommands\";\r\n\r\n// export interface IProps {\r\n//   editorState: EditorState;\r\n//   toolbar: any;\r\n//   editorRef: Function;\r\n//   onChange: Function;\r\n//   readOnly: boolean;\r\n// }\r\n\r\nconst getDecoratorLength = obj => {\r\n  let decorators;\r\n\r\n  if (obj.decorators != null) {\r\n    decorators = obj.decorators;\r\n  } else if (obj._decorators != null) {\r\n    decorators = obj._decorators;\r\n  }\r\n\r\n  return decorators.size != null ? decorators.size : decorators.length;\r\n};\r\n\r\nexport default class CustomEditor extends React.Component {\r\n  editor;\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    const plugins = [this.props, ...this.resolvePlugins()];\r\n    plugins.forEach(plugin => {\r\n      if (typeof plugin.initialize !== \"function\") return;\r\n      plugin.initialize(this.getPluginMethods());\r\n    });\r\n\r\n    // attach proxy methods like `focus` or `blur`\r\n    proxies.forEach(method => {\r\n      this[method] = (...args) => this.editor[method](...args);\r\n    });\r\n\r\n    this.state = { readOnly: false }; // TODO for Nik: ask ben why this is relevent\r\n  }\r\n  componentWillMount() {\r\n    const decorator = resolveDecorators(\r\n      this.props,\r\n      this.getEditorState,\r\n      this.onChange\r\n    );\r\n\r\n    const editorState = EditorState.set(this.props.editorState, { decorator });\r\n    this.onChange(moveSelectionToEnd(editorState));\r\n  }\r\n  componentWillReceiveProps(next) {\r\n    const curr = this.props;\r\n    const currDec = curr.editorState.getDecorator();\r\n    const nextDec = next.editorState.getDecorator();\r\n\r\n    // If there is not current decorator, there's nothing to carry over to the next editor state\r\n    if (!currDec) return;\r\n    // If the current decorator is the same as the new one, don't call onChange to avoid infinite loops\r\n    if (currDec === nextDec) return;\r\n    // If the old and the new decorator are the same, but no the same object, also don't call onChange to avoid infinite loops\r\n    if (\r\n      currDec &&\r\n      nextDec &&\r\n      getDecoratorLength(currDec) === getDecoratorLength(nextDec)\r\n    )\r\n      return;\r\n\r\n    const editorState = EditorState.set(next.editorState, {\r\n      decorator: currDec\r\n    });\r\n    this.onChange(moveSelectionToEnd(editorState));\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.resolvePlugins().forEach(plugin => {\r\n      if (plugin.willUnmount) {\r\n        plugin.willUnmount({\r\n          getEditorState: this.getEditorState,\r\n          setEditorState: this.onChange\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  // Cycle through the plugins, changing the editor state with what the plugins\r\n  // changed (or didn't)\r\n  onChange = editorState => {\r\n    let newEditorState = editorState;\r\n    this.resolvePlugins().forEach(plugin => {\r\n      if (plugin.onChange) {\r\n        newEditorState = plugin.onChange(\r\n          newEditorState,\r\n          this.getPluginMethods()\r\n        );\r\n      }\r\n    });\r\n\r\n    if (this.props.onChange) {\r\n      this.props.onChange(newEditorState, this.getPluginMethods());\r\n    }\r\n  };\r\n  editorRef = (ref) => {\r\n    this.editor = ref;\r\n  };\r\n  getPlugins = () => this.props.plugins.slice(0);\r\n  getProps = () => ({ ...this.props });\r\n\r\n  // TODO further down in render we use readOnly={this.props.readOnly || this.state.readOnly}. Ask Ben why readOnly is here just from the props? Why would plugins use this instead of just taking it from getProps?\r\n  getReadOnly = () => this.props.readOnly;\r\n  setReadOnly = readOnly => {\r\n    if (readOnly !== this.state.readOnly) this.setState({ readOnly });\r\n  };\r\n\r\n  getEditorRef = () => this.editor;\r\n\r\n  getEditorState = () => this.props.editorState;\r\n\r\n  getPluginMethods = () => ({\r\n    getPlugins: this.getPlugins,\r\n    getProps: this.getProps,\r\n    setEditorState: this.onChange,\r\n    getEditorState: this.getEditorState,\r\n    getReadOnly: this.getReadOnly,\r\n    setReadOnly: this.setReadOnly,\r\n    getEditorRef: this.getEditorRef\r\n  });\r\n  createEventHooks = (methodName, plugins) => (...args) => {\r\n    const newArgs = [].slice.apply(args);\r\n    newArgs.push(this.getPluginMethods());\r\n\r\n    return plugins.some(\r\n      plugin =>\r\n        typeof plugin[methodName] === \"function\" &&\r\n        plugin[methodName](...newArgs) === true\r\n    );\r\n  };\r\n  createHandleHooks = (methodName, plugins) => (...args) => {\r\n    const newArgs = [].slice.apply(args);\r\n    newArgs.push(this.getPluginMethods());\r\n\r\n    return plugins.some(\r\n      plugin =>\r\n        typeof plugin[methodName] === \"function\" &&\r\n        plugin[methodName](...newArgs) === \"handled\"\r\n    )\r\n      ? \"handled\"\r\n      : \"not-handled\";\r\n  };\r\n  createFnHooks = (methodName, plugins) => (...args) => {\r\n    const newArgs = [].slice.apply(args);\r\n\r\n    newArgs.push(this.getPluginMethods());\r\n\r\n    if (methodName === \"blockRendererFn\") {\r\n      let block= { props: {} };\r\n      plugins.forEach(plugin => {\r\n        if (typeof plugin[methodName] !== \"function\") return;\r\n        const result = plugin[methodName](...newArgs);\r\n        if (result !== undefined && result !== null) {\r\n          const { props: pluginProps, ...pluginRest } = result; // eslint-disable-line no-use-before-define\r\n          const { props, ...rest } = block; // eslint-disable-line no-use-before-define\r\n          block = {\r\n            ...rest,\r\n            ...pluginRest,\r\n            props: { ...props, ...pluginProps }\r\n          };\r\n        }\r\n      });\r\n\r\n      return block.component ? block : false;\r\n    } else if (methodName === \"blockStyleFn\") {\r\n      let styles;\r\n      plugins.forEach(plugin => {\r\n        if (typeof plugin[methodName] !== \"function\") return;\r\n        const result = plugin[methodName](...newArgs);\r\n        if (result !== undefined && result !== null) {\r\n          styles = (styles ? `${styles} ` : \"\") + result;\r\n        }\r\n      });\r\n\r\n      return styles || \"\";\r\n    }\r\n\r\n    let result;\r\n    const wasHandled = plugins.some(plugin => {\r\n      if (typeof plugin[methodName] !== \"function\") return false;\r\n      result = plugin[methodName](...newArgs);\r\n      return result !== undefined;\r\n    });\r\n    return wasHandled ? result : false;\r\n  };\r\n  createPluginHooks = () => {\r\n    const pluginHooks = {};\r\n    const eventHookKeys = [];\r\n    const handleHookKeys = [];\r\n    const fnHookKeys = [];\r\n    const plugins = [this.props, ...this.resolvePlugins()];\r\n\r\n    plugins.forEach(plugin => {\r\n      Object.keys(plugin).forEach(attrName => {\r\n        if (attrName === \"onChange\") return;\r\n\r\n        // if `attrName` has been added as a hook key already, ignore this one\r\n        if (\r\n          eventHookKeys.indexOf(attrName) !== -1 ||\r\n          fnHookKeys.indexOf(attrName) !== -1\r\n        )\r\n          return;\r\n\r\n        const isEventHookKey = attrName.indexOf(\"on\") === 0;\r\n        if (isEventHookKey) {\r\n          eventHookKeys.push(attrName);\r\n          return;\r\n        }\r\n\r\n        const isHandleHookKey = attrName.indexOf(\"handle\") === 0;\r\n        if (isHandleHookKey) {\r\n          handleHookKeys.push(attrName);\r\n          return;\r\n        }\r\n\r\n        // checks if `attrName` ends with 'Fn'\r\n        const isFnHookKey = attrName.length - 2 === attrName.indexOf(\"Fn\");\r\n        if (isFnHookKey) {\r\n          fnHookKeys.push(attrName);\r\n        }\r\n      });\r\n    });\r\n\r\n    eventHookKeys.forEach(attrName => {\r\n      pluginHooks[attrName] = this.createEventHooks(attrName, plugins);\r\n    });\r\n\r\n    handleHookKeys.forEach(attrName => {\r\n      pluginHooks[attrName] = this.createHandleHooks(attrName, plugins);\r\n    });\r\n\r\n    fnHookKeys.forEach(attrName => {\r\n      pluginHooks[attrName] = this.createFnHooks(attrName, plugins);\r\n    });\r\n\r\n    return pluginHooks;\r\n  };\r\n  resolvePlugins = () => {\r\n    const plugins = (this.props.plugins || []).slice(0);\r\n    if (this.props.defaultKeyBindings === true) {\r\n      plugins.push(defaultKeyBindings);\r\n    }\r\n    if (this.props.defaultKeyCommands === true) {\r\n      plugins.push(defaultKeyCommands);\r\n    }\r\n\r\n    return plugins;\r\n  };\r\n  resolveAccessibilityProps = () => {\r\n    let accessibilityProps = {};\r\n    const plugins = [this.props, ...this.resolvePlugins()];\r\n    plugins.forEach(plugin => {\r\n      if (typeof plugin.getAccessibilityProps !== \"function\") return;\r\n      const props = plugin.getAccessibilityProps();\r\n      const popupProps = {};\r\n\r\n      if (accessibilityProps.ariaHasPopup === undefined) {\r\n        popupProps.ariaHasPopup = props.ariaHasPopup;\r\n      } else if (props.ariaHasPopup === \"true\") {\r\n        popupProps.ariaHasPopup = \"true\";\r\n      }\r\n\r\n      if (accessibilityProps.ariaExpanded === undefined) {\r\n        popupProps.ariaExpanded = props.ariaExpanded;\r\n      } else if (props.ariaExpanded === true) {\r\n        popupProps.ariaExpanded = true;\r\n      }\r\n\r\n      accessibilityProps = {\r\n        ...accessibilityProps,\r\n        ...props,\r\n        ...popupProps\r\n      };\r\n    });\r\n\r\n    return accessibilityProps;\r\n  };\r\n\r\n  render() {\r\n    const pluginHooks = this.createPluginHooks();\r\n    const accessibilityProps = this.resolveAccessibilityProps();\r\n\r\n    return (\r\n      <Editor\r\n        wrapperClassName=\"demo-wrapper\"\r\n        editorClassName=\"demo-editor\"\r\n        editorState={this.props.editorState}\r\n        onEditorStateChange={this.onChange}\r\n        toolbar={this.props.toolbar}\r\n        editorRef={this.editorRef}\r\n        readOnly={this.props.readOnly || this.state.readOnly}\r\n        {...this.props}\r\n        {...accessibilityProps}\r\n        {...pluginHooks}\r\n      // customStyleMap={customStyleMap}\r\n      // blockRenderMap={blockRenderMap}\r\n      />\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport MuiThemeProvider from \"material-ui/styles/MuiThemeProvider\";\r\nimport Image from \"./image\";\r\nimport {\r\n  EditorState,\r\n  convertToRaw,\r\n  convertFromRaw,\r\n  ContentState\r\n} from \"draft-js\";\r\nimport { Editor } from \"react-draft-wysiwyg\";\r\nimport CustomEditor from \"./customEditor\";\r\nimport draftToHtml from \"draftjs-to-html\";\r\nimport htmlToDraft from \"html-to-draftjs\";\r\nimport composeDecorators from \"./composeDecorators\";\r\n\r\nimport createImagePlugin from \"draft-js-image-plugin\";\r\nimport createAlignmentPlugin from \"draft-js-alignment-plugin\";\r\nimport createFocusPlugin from \"draft-js-focus-plugin\";\r\nimport createResizeablePlugin from \"draft-js-resizeable-plugin\";\r\nimport createBlockDndPlugin from \"draft-js-drag-n-drop-plugin\";\r\n\r\nconst focusPlugin = createFocusPlugin();\r\nconst resizeablePlugin = createResizeablePlugin();\r\nconst blockDndPlugin = createBlockDndPlugin();\r\nconst alignmentPlugin = createAlignmentPlugin();\r\nconst { AlignmentTool } = alignmentPlugin;\r\n\r\nconst decorator = composeDecorators(\r\n  resizeablePlugin.decorator,\r\n  alignmentPlugin.decorator,\r\n  focusPlugin.decorator,\r\n  blockDndPlugin.decorator\r\n);\r\nconst imagePlugin = createImagePlugin({ decorator });\r\nconst plugins = [\r\n  blockDndPlugin,\r\n  focusPlugin,\r\n  alignmentPlugin,\r\n  resizeablePlugin,\r\n  imagePlugin\r\n];\r\nconst initialState = {\r\n  entityMap: {\r\n    \"0\": {\r\n      type: \"IMAGE\",\r\n      mutability: \"IMMUTABLE\",\r\n      data: {\r\n        src:\r\n          \"https://www.draft-js-plugins.com/images/canada-landscape-small.jpg\"\r\n      }\r\n    }\r\n  },\r\n  blocks: [\r\n    {\r\n      key: \"9gm3s\",\r\n      text:\r\n        \"You can have images in your text field. This is a very rudimentary example, but you can enhance the image plugin with resizing, focus or alignment plugins.\",\r\n      type: \"unstyled\",\r\n      depth: 0,\r\n      inlineStyleRanges: [],\r\n      entityRanges: [],\r\n      data: {}\r\n    },\r\n    {\r\n      key: \"ov7r\",\r\n      text: \" \",\r\n      type: \"atomic\",\r\n      depth: 0,\r\n      inlineStyleRanges: [],\r\n      entityRanges: [\r\n        {\r\n          offset: 0,\r\n          length: 1,\r\n          key: 0\r\n        }\r\n      ],\r\n      data: {}\r\n    },\r\n    {\r\n      key: \"e23a8\",\r\n      text: \"See advanced examples further down …\",\r\n      type: \"unstyled\",\r\n      depth: 0,\r\n      inlineStyleRanges: [],\r\n      entityRanges: [],\r\n      data: {}\r\n    }\r\n  ]\r\n};\r\n\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    // const html = \"<p>Hey this <strong>editor</strong> rocks 😀</p>\";\r\n    // const contentBlock = htmlToDraft(html);\r\n    // if (contentBlock) {\r\n    //   const contentState = ContentState.createFromBlockArray(\r\n    //     contentBlock.contentBlocks\r\n    //   );\r\n    //   const editorState = EditorState.createWithContent(contentState);\r\n    const editorState = EditorState.createWithContent(\r\n      convertFromRaw(initialState)\r\n    );\r\n    this.state = {\r\n      editorState\r\n    };\r\n  }\r\n  onEditorStateChange = editorState => {\r\n    this.setState({\r\n      editorState\r\n    });\r\n  };\r\n  // onInsertImage = () => {\r\n  //   debugger;\r\n  //   const { editorState } = this.state;\r\n  //   let html = draftToHtml(convertToRaw(editorState.getCurrentContent()));\r\n  //   html +=\r\n  //     '<image src=\"https://www.google.com/webhp?hl=en&ictx=2&sa=X&ved=0ahUKEwi2p9HcqLnhAhUiTd8KHTyyAywQPQgH\"></image>';\r\n  //   const contentBlock = htmlToDraft(html);\r\n  //   if (contentBlock) {\r\n  //     const contentState = ContentState.createFromBlockArray(\r\n  //       contentBlock.contentBlocks\r\n  //     );\r\n  //     const editorState = EditorState.createWithContent(contentState);\r\n  //     this.setState({\r\n  //       editorState\r\n  //     });\r\n  //   }\r\n  // };\r\n  onChange = (editorState) => {\r\n    console.log(editorState);\r\n  }\r\n  render() {\r\n    const { editorState } = this.state;\r\n\r\n    return (\r\n      <MuiThemeProvider>\r\n        <div>\r\n          <Editor\r\n            // plugins={plugins}\r\n            wrapperClassName=\"demo-wrapper\"\r\n            editorClassName=\"demo-editor\"\r\n            onChange={this.onChange}\r\n            editorState={editorState}\r\n            toolbar={{\r\n              options: [\r\n                \"inline\",\r\n                \"blockType\",\r\n                \"fontSize\",\r\n                \"fontFamily\",\r\n                \"list\",\r\n                \"textAlign\",\r\n                \"colorPicker\",\r\n                \"image\",\r\n                \"history\"\r\n              ],\r\n              fontFamily: {\r\n                options: [\r\n                  \"Arial\",\r\n                  \"Comic Sans MS\",\r\n                  \"Consolas\",\r\n                  \"Courier New\",\r\n                  \"Georgia\",\r\n                  \"Tahoma\",\r\n                  \"Times New Roman\",\r\n                  \"Verdana\"\r\n                ],\r\n                className: undefined,\r\n                component: undefined,\r\n                dropdownClassName: undefined\r\n              }\r\n            }}\r\n          />\r\n          <textarea\r\n            disabled\r\n            value={draftToHtml(convertToRaw(editorState.getCurrentContent()))}\r\n          />\r\n          {/* <button onClick={this.onInsertImage}>Insert image</button> */}\r\n        </div>\r\n      </MuiThemeProvider>\r\n    );\r\n  }\r\n}\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nReactDOM.render(<App />, rootElement);\r\n","export default (...funcs) => {\r\n  if (funcs.length === 0) {\r\n    return arg => arg;\r\n  }\r\n\r\n  if (funcs.length === 1) {\r\n    return funcs[0];\r\n  }\r\n\r\n  const last = funcs[funcs.length - 1];\r\n  return (...args) => {\r\n    let result = last(...args);\r\n    for (let i = funcs.length - 2; i >= 0; i -= 1) {\r\n      const f = funcs[i];\r\n      result = f(result);\r\n    }\r\n    return result;\r\n  };\r\n};\r\n"],"sourceRoot":""}